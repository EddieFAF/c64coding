;***********************************************************************
;**  Project Name: Loader                                             **
;**  ---------------------------------------------------------------  **
;**  Filename: loader.a                                               **
;**  ---------------------------------------------------------------  **
;**  Author (c): Eddie                                                **
;**  File Date: 2018-02-28                                            **
;***********************************************************************
;Meine persönliche Reihenfolge ist anders.
; -Macros,
; -Includes von Daten mit fester Adresse (Musik, Grafik...)
;-Basic-Zeile und ein erstes bisschen Code wie Kopierschleifen o.Ä. dazu.
;-Dann für größere Funktionsblöcke, z.B. Diskroutinen, Zeichenroutinen, Raster-IRQs...:
; [ -Variablen
; -Unterprogramme: Deren lokale Variablen, dann der Code dazu
; -Der eigentliche Code]
; Und zu guter Letzt die Hauptroutine, die all die anderen Sachen verwendet.


!src "../macros.a" ; Stellt ein paar Macros bereit
!src "../variables.a" ; Sprungziele

;my Routine, that starts with a nice BASIC line
!macro der_text {
  !pet "faf world domination"
}
year = 1971
!src "../basicstart_template.a"

        jmp start

!src "../subroutines.a"


raster_set_space:
; **********************
; ** setze 'Warten auf Space'
; **********************
        lda #<wait_space
        sta sprite_change+1
        lda #>wait_space
        sta sprite_change+2
        lda #$00
        sta SPRITEACTIV
        rts

wait_space:
; **********************
; ** Warten auf Space
; **********************
        lda #$7f       ; detect space bar
        sta $dc00
        lda $dc01
        and #$10
        bne +
        jmp sprite_set_rts        
+       rts


sprite_set_rts:        
; **********************
; ** setze RTS
; **********************
        lda #<sprite_set_rts_exit
        sta sprite_change+1
        lda #>sprite_set_rts_exit
        sta sprite_change+2
sprite_set_rts_exit
        rts

; **********************


start
RASTER          = $6f                ;Hier den 1. Raster-IRQ auslösen
 
        jsr $e544                          ;Bildschirm löschen
        +SetBorderColor 14
        +SetBackgroundColor 6
        
        sei                                ;IRQs sperren
        lda #<myIRQ                        ;Adresse unserer Routine in
        sta $0314                          ;den RAM-Vektor
        lda #>myIRQ
        sta $0315
        lda #%00000001                     ;Raster-IRQs vom VIC-II aktivieren
        sta $d01a
        lda #RASTER                        ;Hier soll unsere Linie erscheinen
        sta $d012                      
        lda $d011                          ;Zur Sicherheit höchste BIT
        and #%01111111                     ;für die Rasterzeile löschen
        sta $d011
        lda #%01111111                     ;Timer-IRQs abschalten
        sta $dc0d
        lda $dc0d
        lda #%0000001                      ;evtl. aktiven Raster-IRQ bestätigen
        sta $d019
        cli 
                          
        jmp *
 
;*** an Pagegrenze ausrichten, damit die Sprünge passen
!align 255,0
 
myIRQ
        lda #<doubleIRQ                    ;(2 TZ) 2. Raster-IRQ einrichten
        sta $0314                          ;(4 TZ)
        lda #>doubleIRQ                    ;(2 TZ)
        sta $0315                          ;(4 TZ)
        tsx                                ;(2 TZ) Stackpointer im X-Reg. retten
        stx doubleIRQ+1                    ;(4 TZ) und fürs zurückholen sichern!
        nop                                ;(2 TZ)
        nop                                ;(2 TZ)
        nop                                ;(2 TZ)
        lda #%00000001                     ;(2 TZ) 1. Raster-IRQ später bestätigen
 
        inc $d012                          ;(6 TZ) 2. IRQ in der übernächsten Zeile (RASTER+2)!!!
        sta $d019                          ;(4 TZ) IRQ bestätigen
        cli                                ;(2 TZ) Interrupts für den 2. Raster-IRQ
 
        ldx #$08                           ;            2 TZ
        dex                                ;8 * 2 TZ = 16 TZ
        bne *-1                            ;7 * 3 TZ = 21 TZ
 
        nop
        nop
        nop
        nop
        nop
        nop
 
doubleIRQ
        ldx #$00                           ;(2 TZ) Platzhalter für 1. Stackpointer
        txs                                ;(2 TZ) Stackpointer vom 1. IRQ wiederherstellen
        nop                                ;(2 TZ)
        nop                                ;(2 TZ)
        nop                                ;(2 TZ)
        nop                                ;(2 TZ)
        bit $01                            ;(3 TZ)
        ldx $D012                          ;(4 TZ)
        lda #$01                           ;(2 TZ) weiß schonmal in den Akku
        cpx $D012                          ;(4 TZ) sind wir noch in Rasterzeile 22?
 
        beq myIRQMain                      ;(3 TZ) wenn JA einen letzten Takt 'verschwenden'
 
myIRQMain
        ldx #$ff                           ;X mit -1 initialisieren, da gleich INX folgt!
nextColor
        inx                                ;Schleifenzähler erhöhen
        ldy delaytable,X                   ;Wartezeit holen
        dey                                ;verringern
        bne *-1                            ;solange größer 0 zurück zum DEY
        lda rowcolortable,X                ;Farbe holen
        sta $d021                          ;und ins Register für die Hintergrundfarbe
        ;nop                                ;ahhhh einfach mal nichts 'tun'
        cpx #$42
        bne nextColor                      ;solange die Farbe positiv ist -> @loop
        +SetBackgroundColor 6
        lda #<myIRQ                        ;Original IRQ-Vektor setzen
        sta $0314
        lda #>myIRQ
        sta $0315
 
        lda #RASTER
        sta $d012
 
        lda #%00000001                     ;IRQ bestätigen
        sta $d019
sprite_change
        jsr color_move
        jmp $ea81                          ;zum Ende des 'Timer-Interrupts' springen

dela    !byte 00 
tabcount    !byte 00

color_move
        ldx dela
        inx
        stx dela
        cpx #$02
        beq col_mov
        rts
        
col_mov ldx #$00
        stx dela
        ldx tabcount
        inx
        stx tabcount
        cpx #$21
        bne cont1
        jmp sprite_set_rts
cont1:
        ldx #$00
-       lda rowcolor1+$02,x        
        sta rowcolortable,x        
        inx
        cpx #$21
        bne -

        ldx #$00
-       lda rowcolor2,x
        sta rowcolortable+$21,x
        inx
        cpx #$21
        bne -
        jsr copy_tabs
        rts

;umkopieren der Tabellen
copy_tabs:
        ldx #$00
-       lda rowcolor1+1,x
        sta rowcolor1,x
        inx
        cpx #$22
        bne -
        lda #$00
        sta rowcolor1+$22
        
        ldx #$22
-       lda rowcolor2,x
        sta rowcolor2+1,x
        dex
        bpl -
        lda #$00
        sta rowcolor2
        rts
        
        
!align 255,0
rowcolortable !fill $50,0

rowcolor1
        !byte 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
        !byte 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6

;            70,71,72,73,74,75,76,77,78,79,7a,7b,7c,7d,7e,7f
        !byte 6, 6, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        !byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        !byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
        !byte 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
rowcolor2        
        !byte 1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
        !byte 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
        !byte 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
        !byte 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
        !byte 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6
        !byte $f6
 
 
!align 255,0
delaytable
 !byte 9                            ;letzte Zeile vor der Anzeige        
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ; 1. Textzeile
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ; 2. 
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ; 3. 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ; 4. 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ; 5. 
 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ; 6. 
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ; 7. 
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ; 8. 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ; 9. 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;10. Textzeile
 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;11.
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ;12.
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ;13.
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;14.
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;15.
 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;16.
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ;17.
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ;18.
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;19.
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;20. Textzeile
 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;21.
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ;22.
 !byte 2, 8, 8, 9, 9, 9, 9, 10      ;23.
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;24.
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;25. Textzeile
 
 !byte 2, 8, 8, 9, 9, 9, 9, 9       ;26. 'Sicherheitszeile'

